#summary A description of the Web Data Model, a lowest-common-denominator model for data on the web
#labels Phase-Design

= Introduction =

Web sites implicitly expose a common data model to clients, but exactly what does that data model consist of? This document attempts to describe the lowest-common-denominator for most websites; that model is what the in-memory database in Itemscript attempts to emulate.

Obviously, real sites differ in various ways from the idealized variation described here. The most common way is that access to resources may involve a request with a query-string even when what is happening is not technically a "query". For the purposes of this description, we're going to ignore that.

== What is a URL? ==

We're going to assume that the URLs we're talking about are of typical generic form as described in [http://www.ietf.org/rfc/rfc2396.txt RFC2396]. We will assume that any relative URL has been converted to absolute form first. As far as we're concerned 

== What is a website? ==

A website is a server that contains resources and makes them available to clients. It may support certain types of queries on resources, or queries that answer other questions. It may allow specific resources to be changed in whole, or it may accept certain other kinds of changes that don't specifically affect a single resource, or affect only a sub-part of them.

For the purposes of this discussion, a "website" is identified by everything up to and including the server name and port number in a URL - the scheme, hostname, and port number. For instance, `http://example.com`, or `ftp://foo.com:2323`. The internal details of the "website" part can be ignored.

== What is a resource? ==

A resource is a bunch of data with a content-type, encoding, and other metadata associated with it that helps the client interpret it. It might be a file, a web page, something generated by a database, and so on; what is important is that to the client, it is always identified by the same path.

For the purposes of this discussion, a "resource" is identified by the path section of a URL - everything between the hostname/port-number and the end of the path (which may be marked by a query-string or fragment). For instance, `/some/path/` or `/images/foo.gif`.

We're not going to distinguish between "files" and "directories" initially, and therefore the presence or absence of a trailing slash on the path is irrelevant.

All paths start with a slash and are therefore rooted at the base of the resources a server offers; the rest of the path is divided by slashes and URL-decoded to the names of sub-resources. The model corresponds roughly to a List`<String>` in Java, or symbolically in  JSON, the path string `/some/path/foo.gif` would correspond to:

{{{
[
    "/",
    "some",
    "path",
    "foo.gif"
]
}}}

The initial "/" entry reminds us that all navigation starts from the root in an absolute URL. All paths have at least that "/" entry.

== What is a query? ==

A query is something asked of (or about) a given resource, indicated by the presence of a query-string in the URL after the path. A query does not necessarily return a given resource, but may return information _about_ resources.

For the purposes of this discussion, a "query" is identified by the query-string section of a URL, everything between the end of the path and either the end of the URL or the beginning of the fragment section, and the actual query is decoded to an unordered set of keys and values, in which each key may have one or more string values. Keys with no value are assumed to have a value of an empty string. Roughly, this is a Map`<String, List<String>>` in Java. For instance, in the URL `http://example.com/abc?key=value&multiKey=foo&multiKey=bar&emptyKey` the query looks a bit like this in JSON:

{{{
{
    "key" : [
        "value"
    ],
    "multiKey" : [
        "foo",
        "bar"
    ],
    "emptyKey" : []
}
}}}

== What is the model for organization of resources? ==

So how are resources organized on the server, at least as far as clients can see?

What is exposed to clients looks a lot like a filesystem, but has some important differences. Like a filesystem, it is a rooted, tree-structured model where nodes in the tree can have sub-nodes; unlike a filesystem, which draws a distinction between nodes with values (files) and nodes with sub-nodes (directories), that distinction is blurred on websites.

So, for instance, it is common to serve one resource at `http://example.com/foo` and another at `http://example.com/foo/bar.html` without a real distinction being made that the former is a "directory" and the latter is a "file". Technically speaking, the former might be a directory and the resource served might be "index.html", but to the client this is not apparent; nor is really apparent that `bar.html` represents a file and that a resource named `/foo/bar.html/xyz` might not also be available.

You can imagine this as being represented by the following JSON structure (and this is in fact the format used by dump operations on the Itemscript database):

{{{
{
    "value" : "",
    "subItems" : {
        "foo" : {
            "value" : "",
            "subItems" : {
                "bar.html" : {
                    "value" : "<html>etc etc</html>",
                     "subItems" : {}
                }
            }
        }
    }
}
}}}

Whether this is actually how it is implemented is not really the point; this is how it appears to clients. Not all nodes accept sub-nodes (for instance, in reality `bar.html` is unlikely to accept them) but that's really a restriction of the more general model, rather than a general rule in itself. For the purposes of this discussion, we'll assume that we are simply talking about a hierarchical tree of generic nodes that can have both values and sub-nodes, and that we navigate our way down this tree from the root using the series of keys given in the path.

== What can we do? ==

Obviously most web servers don't allow just any old users to replace any resource they feel like, and the most common operation does not involve putting a new resource under a given path, but in sending some additional data and letting the server figure out a path to put it under. REST-style sites correspond most closely to the "put a whole resource" model; as do sites like Wikipedia that let you edit a resource and allow creation of hierarchically-organized sub-resources below any other resource.

For the purposes of this discussion, we'll assume that permissions are irrelevant and that the user is allowed

== What operations are available? ==

We're going to restrict the discussion to some common, simple operations. Some of these are very basic and supported by almost all web servers; others are implemented in various ways on various systems, but we're going to describe a common set of operations here and how they apply to an idealized server.

HTTP GET
  * 1.1 - Get a particular resource.
  * 1.2 - Get part of a particular resource.
  * 1.3 - Get the results of a query.
  * 1.4 - Get part of the results of a query.

HTTP PUT
  * 2.1 - Put a new whole value for a resource, whether that resource existed before or not.

HTTP POST
  * 3.1 - Change a sub-value of a resource.
  * 3.2 - Perform some other state-changing operation on the server.

HTTP DELETE
  * 4.1 - Remove a resource.

These are mapped to the following combinations of methods and types of URL supplied to the three Map-style methods in Itemscript that are used to query, retrieve, or change data - `get`, `put`, and `remove`.

`get`
  * 1.1 - URL with no query string or fragment.
  * 1.2 - URL with no query string, with a fragment.
  * 1.3 - URL with a query string and no fragment.
  * 1.4 - URL with a query string and a fragment.

`put`
  * 2.1 - URL with no query string or fragment.
  * 3.1 - URL with no query string, with a fragment.
  * 3.2 - URL with a query string and no fragment.

`remove`
  * 4.1 - URL with no query string or fragment.
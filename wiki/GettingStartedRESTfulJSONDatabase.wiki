#summary How to get started using the in-memory RESTful JSON database in the Itemscript library.
#labels Featured,Phase-Implementation

== Create a `JsonSystem` ==

See one of the general Getting Started pages: GettingStartedStandardJava for a standard Java environment, or GettingStartedGwtJava for the GWT Java environment.

We're going to use the `StandardConfig` here; if you're using GWT, just use the `GwtSystem.SYSTEM` instance. The database facilities are identical in either environment.

{{{
    JsonSystem system = StandardConfig.createSystem();
}}}

== Store some values ==

Any type of `JsonValue` can be stored, not just `JsonObjects`.

If no scheme is supplied to `put` or `get`, the supplied URL is considered to be relative to `mem:/`. So, `/Test/a` will end up being `mem:/Test/a`.

{{{
        system.put("/Test/a", "A string value");
        system.put("/Test/b", 123);
        system.put("/Test/c", false);
        system.put("/Test/d", system.createObject()
                .p("x", "y"));
        system.put("/Test/e", system.createArray()
                .a("one")
                .a("two")
                .a("three"));
        system.putNative("/Test/f", new Date());
}}}

== Retrieve some values ==

We'll use some of the null-safe conversion methods to access the values we just stored.

{{{
        String stringValue = system.getString("/Test/a");
        System.out.println("stringValue: " + stringValue);
        int intValue = system.getInt("/Test/b");
        System.out.println("intValue: " + intValue);
        boolean booleanValue = system.getBoolean("/Test/c");
        System.out.println("booleanValue: " + booleanValue);
        JsonObject objectValue = system.getObject("/Test/d");
        System.out.println("objectValue: " + objectValue);
        JsonArray arrayValue = system.getArray("/Test/e");
        System.out.println("arrayValue: " + arrayValue);
        Date dateValue = (Date) system.getNative("/Test/f");
        System.out.println("dateValue: " + dateValue);
}}}

prints:

{{{
stringValue: xyz
intValue: 123
booleanValue: false
objectValue: {
    "x" : "y"
}

arrayValue: [
    "one",
    "two",
    "three"
]

dateValue: Thu Mar 04 17:45:16 PST 2010
}}}

== Automatically create intermediate database items ==

We actually relied on this feature above, but this is an explicit example. The following fragment creates the items "/Test/one", "/Test/one/two", and "/Test/one/two/three", then sets the value "qwerty" in the node "/Test/one/two/three".

{{{
        system.put("/Test/one/two/three", "qwerty");
}}}

== Retrieve some values using fragments ==

You can supply a fragment to the URL being retrieved, and it will be used to navigate the value retrieved from the database. (You can also use this when loading data from a non-`mem:` scheme URL, since it relates strictly to navigating the structure.)

{{{
        String objectStringValue = system.getString("/Test/d#x");
        System.out.println("objectStringValue: " + objectStringValue);
        String arrayStringValue = system.getString("/Test/e#2");
        System.out.println("arrayStringValue: " + arrayStringValue);
}}}

prints:

{{{
objectStringValue: y
arrayStringValue: three
}}}

Of course, if the value is not an object or an array, supplying a fragment is an error, since they don't have any internal structure to navigate.

== Store a new value using a fragment ==

Note that when a value is put with a fragment when the item did not already exist, the item is created with a `JsonObject` value and the value supplied to put is set inside that object using the fragment. The fragment is divided into separate keys by slashes, those keys are URL-decoded, and the resulting list of keys is used to navigate inside the object. Missing intermediate values inside the object are created as new `JsonObjects` too.

{{{
        system.put("/Test/g#foo/bar", "xyz");
        JsonObject fragmentPutObject = system.getObject("/Test/g");
        System.out.println("fragmentPutObject: " + fragmentPutObject);
}}}

prints:

{{{
fragmentPutObject: {
    "foo" : {
        "bar" : "xyz"
    }
}
}}}

You can only `put` a value with a fragment URL to a `mem:` scheme URL; for any other scheme, you must `put` the entire new value for a resource, not just one sub-part, since fragments apply only to navigating local resources.

== Query the database ==

The `mem:` scheme allows certain kinds of queries to be performed on the database.

{{{
       int count = system.getInt("/Test/?countItems");
       System.out.println("count: " + count);
}}}

prints:

{{{
count: 8
}}}

You can also get a list of the keys of the sub-items of an item in the database:

{{{
        JsonArray keys = system.getArray("/Test?keys");
        System.out.println("keys: " + keys);
}}}

prints:

{{{
keys: [
    "f",
    "g",
    "d",
    "e",
    "b",
    "c",
    "one",
    "a"
]
}}}

Or a sorted sub-set of those keys:

{{{
        JsonArray pagedKeys = system.getArray("/Test?pagedKeys&startRow=0&numRows=4");
        System.out.println("pagedKeys: " + pagedKeys);
}}}

prints:

{{{
pagedKeys: [
    "a",
    "b",
    "c",
    "d"
]
}}}

Or a sorted sub-set of the keys and the values of those items (useful for a paged table of results, for instance):

{{{
        JsonArray pagedItems = system.getArray("/Test?pagedItems&startRow=0&numRows=4");
        System.out.println("pagedItems: " + pagedItems);
}}}

prints:

{{{
pagedItems: [
    [
        "a",
        "xyz"
    ],
    [
        "b",
        123
    ],
    [
        "c",
        false
    ],
    [
        "d",
        {
            "x" : "y"
        }
    ]
]
}}}

Each of the items in the returned array is itself an array; each of those sub-arrays has as its first element the key of the sub-item, and as the second element the actual value of that sub-item.

By implementing the same queries on an HTTP REST server, you can interchangeably switch between accessing a database locally using the `mem:` scheme, and a remote database using the `http:` scheme.

== Remove an entire item ==

You can remove an entire item (which also removes any sub-items of that item).

{{{
        system.put("/Test/removeMe", "foo");
        system.put("/Test/removeMe/subItem", "foo");
        system.remove("/Test/removeMe");
        String removedValue = system.getString("/Test/removeMe");
        System.out.println("removedValue: " + removedValue);
        String removedSubValue = system.getString("/Test/removeMe/subItem");
        System.out.println("removedSubValue: " + removedSubValue);
}}}

prints:

{{{
removedValue: null
removedSubValue: null
}}}

== Remove part of a value using a fragment ==

When dealing with `mem:` URLs in the in-memory database, you can supply a fragment to `remove` and remove just part of the value of an item, as long as it was a container - either an object or an array.

{{{
        system.put("/Test/array", system.createArray().a("x").a("y").a("z"));
        JsonArray array = system.getArray("/Test/array");
        System.out.println("array, pre-remove: " + array);
        system.remove("/Test/array#1");
        System.out.println("array, post-remove: " + array);
}}}

prints:

{{{
array, pre-remove: [
    "x",
    "y",
    "z"
]

array, post-remove: [
    "x",
    "z"
]
}}}

Note that the actual JsonArray value we retrieved from the database _is_ the value that is changed in the subsequent `remove` operation. The values returned from the database are "live" - you can change them directly.
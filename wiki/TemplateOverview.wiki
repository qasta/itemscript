#summary An overview of the Itemscript template system.
#labels Phase-Implementation

_This is implemented and scheduled for the next release, but is not in the current release._

= Introduction =

The Itemscript system includes a simple template module for interpreting text templates.

This template text:
{{{
This is a number: - {:number} -
This is a string: - {:text} -
This is a boolean: - {:trueBoolean} -

This is a field reference: {:text}

This is a URL reference: {@classpath:org/itemscript/test/templateInclude.txt}

This is a fragment reference: {@#object/a}

This is a comment: {# This is some comment text. }

This is an encoded literal: {&b%3D%7B%25}

These are some braces: {'{'} {'}'}

This a value HTML-encoded: {:containsHtmlChars html}

This is a value URL-encoded: {:containsUrlChars url}

Section:
{.section :object}
A: {:a}
B: {:b}
C: {:c}
Missing field: {d}
{.end}

Foreach:
{.foreach :array}Entry: {:}{.join} - {.end}

{# Note the .join section.}
{# Note also the empty field used when the values in the array are not themselves container objects.}

If:
{.if :trueBoolean}Yes{.else}No{.end}
{.if :falseBoolean}Yes{.else}No{.end}

Missing section:
{.section :doesntExist}
This won't show up.
{.or}
This will show up.
{.end}

Nested directives:
{.foreach :arrayOfObjects}
    Name: {:name}
    {.section :address}
        Street: {:street}
        Zip: {:zip}
    {.end}
{.end}
}}}
interpreted with this context:
{{{
{
    "text" : "xyz",
    "number" : "1.5",
    "trueBoolean" : true,
    "falseBoolean" : false,
    "object" : {
        "a" : "A",
        "b" : "B",
        "c" : "C"
    },
    "array" : [
        "a",
        "b",
        "c"
    ],
    "arrayOfObjects" : [
        {
            "name" : "Jacob",
            "address" : {
                "street" : "10 A Street",
                "zip" : "54321"
            }
        },
        {
            "name" : "Loki",
            "address" : {
                "street" : "20 B Street",
                "zip" : "75633"
            }
        },
        {
            "name" : "Victoria",
            "address" : {
                "street" : "40 C Street",
                "zip" : "34391"
            }
        }
    ],
    "containsHtmlChars" : "<hi> &",
    "containsUrlChars" : "foo&bar:"
}
}}}
produces this result:
{{{
This is a number: - 1.5 -
This is a string: - xyz -
This is a boolean: - true -

This is a field reference: xyz

This is a URL reference: Included text. Note, tags are {not} interpreted.


This is a fragment reference: A

This is a comment: 

This is an encoded literal: b={%

These are some braces: { }

This a value HTML-encoded: &lt;hi&gt; &amp;

This is a value URL-encoded: foo%26bar%3a

Section:

A: A
B: B
C: C
Missing field: 


Foreach:
Entry: a - Entry: b - Entry: c




If:
Yes
No

Missing section:

This will show up.


Nested directives:

    Name: Jacob
    
        Street: 10 A Street
        Zip: 54321
    

    Name: Loki
    
        Street: 20 B Street
        Zip: 75633
    

    Name: Victoria
    
        Street: 40 C Street
        Zip: 34391
}}}

== The Java API ==

(See also `Template` JavaDoc.)
{{{
    Template template = Template.create(system(), text);
    JsonObject context = system().getObject(contextUrl);
    String output = template.interpretToString(context);
}}}

== The JavaScript API ==

(To-do.)

== The basics ==

A template is some text mixed with tags. Certain tags - those starting with a dot,
like `{.foreach}` - are directives that enclose sections of the template to be treated
in various different ways, and may cause the context to change for their contents. Other tags can be used to include values from the context, or to load them from the Itemscript system.

== Ordinary text ==

The text outside of any template tags can contain any characters except `{` and `}`. All characters in the text will be included, including carriage returns and other whitespace.

== {tag} - Tags ==

A tag is contained within curly brackets, like this: `{:fieldName}`. It can contain any characters except carriage returns and curly brackets. Leading and trailing whitespace inside the tag is ignored. The contents are divided by spaces into a series of tokens.

Tags whose first token starts with a dot `.` are treated as directives and interpreted in a special way. Otherwise the contents of the tag are evaluated left-to-right as a series of tokens; usually the first token causes a value to be retrieved (either from the surrounding context or from the system) and subsequent tokens cause that value to be changed in some way, for instance, by being HTML-escaped.

== {:field} - Field references ==

A token whose first character is `:` is treated as a field reference. The portion after the `:` is treated as the field name in the surrounding context. If the portion after the `:` is empty, the entire context is returned.

Field names are URL-decoded before being used, so you should URL-encode any special character you need to. There is currently no quoting syntax so encoding is the only way to include special characters in field names, string literals, and so on.

For instance, `{:name}`

== {# comment} - Comments ==

A token whose first character is a `#` sign ends the interpretation of the token sequence. Note that comments may not include carriage returns or curly braces.

For instance, `{# This is a comment }`

== {@url} - URL references ==

A token whose first character is an `@` sign is treated as a URL reference. The value referred to by the URL is returned. If the URL is relative, it is treated as relative to the system base URL or to the base URL supplied when interpreting the template.

For instance: `{@http://itemscript.org/templateInclude.txt}` or `{@file.txt}` or `{@#fragment}`.

Note that in the last example, `#fragment` will be interpreted as relative to the JsonItem of the surrounding context; if the context has no attached JsonItem, it is an error to use a fragment URL.

== {&literal} - Literal token ==

A token whose first character is a `&` sign is treated as a string literal. The remainder of the first token is URL-decoded and included in the template at that point.

For instance: `{&b%3D%7B%25}`

== {left} & {right}- Braces tags ==

Tags whose contents are `left` or `right` will cause an opening or closing curly brace to be included at that point in the template. This is useful when you need the output text to contain (a few) curly braces. (If you need it to contain a lot of curly braces, it's probably best to create them in some other way.) (Technically, `left` and `right` are functions that return a single curly brace.)

For instance:  `{left}` or `{right}`

== {b64id} - Function tokens ==

Tokens whose first character is a letter will be treated as the name of a function chosen from a limited subset. The functions implemented at present are:

  * `b64id`, which generates a unique random ID using only URL-safe characters, for instance "`H2eBRN-55bZsRzM6xCdU6Q`".
  * `uuid`, which generates a new UUID, for instance. `"3d9f9533-c32f-4183-b78c-f01f32609de4"`.
  * `html`, which HTML-escapes its input.
  * `url`/`uri`, which URL-encodes its input.
  * `dataUrl`, which produces a `data:` URL from its input, which for best results should be a value loaded from a URL so that content-type information is included, for instance, `{@http://www.mozilla.org/images/home/icons/planet.png dataUrl}` turns into a string starting `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf...`

== {.directive} - Directive tags ==

Directives are tags whose first character is a period/dot (`.`). The template portion between an opening directive and its corresponding `{.end}` directive belongs to a segment attached to the opening directive. Different directives cause the enclosed template portion to be interpreted in different ways. The template portion may be divided into different sections by other directives.

A directive that opens a section usually specifies a value to operate on. The value is given by the remaining tokens in the opening directive tag after the first; often this is a field in the context, but it can also be any other token or token sequence, including a URL reference.

For instance: `{.foreach :array}` or `{.end}` or `{.section @http://itemscript.org/test.json#test-object}`

== {.section} directive ==

The `{.section}` directive lets you create a new context for the contained content based on the value returned by the second token in the tag. This lets you "move into" nested objects in your context to access their fields, or open a new context from a value stored in memory or on the network. The field is specified in the token following the `.section` token, and is URL-decoded before being used to look up the value.

For instance, the template:
{{{
Name: {:name}
{.section :address}
Street: {:street}
{.end}
}}}
interpreted with the context:
{{{
{
    "name" : "Jacob",
    "address" : {
        "street" : "10 A Street"
    }
}
}}}
produces the output:
{{{
Name: Jacob

Street: 10 A Street
}}}

You can also specify a section to be included if the field to move into is missing or null, by including an `{.or}` directive before the `{.end}` directive.

For instance:
{{{
{.section :address}
(Address stuff)
{.or}
(No address given)
{.end}
}}}

== {.if} directive ==

The `{.if}` directive lets you test for the existence and "truth" of a value specified by the second token and include different template portions depending on the result. If no field is specified, the surrounding context itself is tested; this is useful, for instance, if you are iterating through a list of boolean values.

The optional `{.else}` directive, if included before the `{.end}` directive, can be used to specify a section that is included if the value is false.

Values are true if they exist in the surrounding context and:
  * are boolean and true
  * are numbers and not zero
  * are strings of length greater than zero

Otherwise they are false. Objects and arrays are false; if you want to test for their existence, the `{.section}` directive is probably what you want.

For instance, the template:
{{{
{.foreach :people}
{.if :alive}Alive{.else}Dead{.end}
{.end}
}}}
interpreted with the context:
{{{
{
    "people" : [
        {
            "alive" : true
        },
        {
            "alive" : false
        }
    ]
}
}}}
produces the output:
{{{
Alive

Dead
}}}

== {.foreach} directive ==

The `{.foreach}` directive can be used to include the contained template section repeatedly, once for each element in an array. The context for each inclusion will be the corresponding element in the array. The field is specified in the token following the `.foreach` token, and is URL-decoded before being used to look up the value.  If no field is specified, the surrounding context itself is used; this is useful when iterating through an array of arrays.

For example:
{{{
{.foreach :letters}"{}"{.join} {.end}
}}}
interpreted with the context:
{{{
{
    "letters" : ["a", "b", "c"]
}
}}}
produces the output:
{{{
    "a" "b" "c"
}}}

You can include a section to be included between entries by including a `{.join}` directive before the `{.end}` directive. If no entries or only one are included, the join section will not be used.

At present there is no way to retrieve the array index or to iterate over a JsonObject.

== Security notes ==

Remember to use the `html` or `url` parameters in tags as appropriate to make sure content included in a template is correctly escaped. User-supplied input included in web pages should almost always be HTML-escaped. Data included in a URL query-string should almost always be URL-encoded.

At present, permission to write a template should be treated as permission to execute arbitrary code as the current user. So, user-supplied templates should not be used except where that condition is acceptable. A restricted subset of the template system that can interpret templates without giving so much access is a possibility for future development. 

This page at the doctype project has a good overview of the potential security problems when displaying user-supplied content: [http://code.google.com/p/doctype/wiki/ArticlesXSS]

== Future development ==

Planned but not scheduled for the near future:
  * Inclusion of other template files
  * An expression language for testing and manipulating values
  * Number-formatting parameter for numeric values
  * Substring parameter for string values
  * Restartable interpretation for asynchronous inclusion of values in GWT/JavaScript
  * Automatic caching of compiled templates